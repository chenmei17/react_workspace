<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body {
            margin: 0
        }

        .wrap {
            width: 100%;
            height: 800px;
            display: flex;
            background: #f0f0f0
        }

        .wrap>div {
            width: 20%;
            padding: 20px 10px;
            box-sizing: border-box;
            background-color: aliceblue;
        }

        .wrap form>* {
            display: block;
            width: 100%;
            margin: 0 0 10px;
            box-sizing: border-box
        }

        .wrap textarea {
            height: 150px;
        }

        .wrap>.content {
            width: 60%;
            background-color: rgb(206, 216, 226);
        }

        .wrap .detail button {
            width: 50%;
            display: inline-block;
        }

        .wrap form .btWr {
            display: flex;
            gap: 5px;
            ;
        }

        table {
            width: 100%;
            border: 1px solid #222;
            border-collapse: collapse;
            line-height: 1.25;
            font-size: 13px;
            background:#fafafa;
        }

        table th,
        table td {
            border: 1px solid #222;
            padding:5px 10px;
        }
    </style>

    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

    <script>
        /*
            React 의 2가지 개발방식 
            1) Vite 프로젝트 개발방식 : 실제 Production 모드, 규모가 클 경우 

            2) CDN 링크 방식: 학습, 연구, 테스트목적. 규모가 작을 경우 
        */
    </script>

</head>

<body>

    <!-- 게시판 애플리케이션이 표현될 영역 -->
    <div id="app"></div>



    <script type="text/babel">
        const root = ReactDOM.createRoot(document.getElementById("app"));

        // class => className="aside"
        // 하나짜리 dom 은 /> 으로 꼭 마감처리 
        // 개발자가 컴포넌트내에 매개변수로 전달할수 있는 데이터를 가리켜 props 라 한다. 

        // 좌측에 글 등록
        function RegistForm(props) {

            const [title, setTitle] = React.useState(""); // useState => 초기값 이라는 뜻! 
            const [writer, setWriter] = React.useState("");
            const [content, setContent] = React.useState("");


            // 메서드 선언 가능
            // 서버에 요청로직을 아래에 바로 작성할 수 있지만 SAP(Single Page Application) 를 만들 예정이므로 
            // 갖은 요청(등록,수정,삭제,목록 등..)을 위해 변수,메서드가 서로 공유되어야 하기 때문에
            // 부모 컴포넌트에 취합해두고 사용한다~
            function handleClick() {
                // 자식 컴포넌트는 부모의 메서드를 직접 접근할 수 없다. 
                console.log("눌렸다.");

                // 글 등록 요청 시 넘기게 될 notice 생성~! 
                const notice = {
                    title: title,
                    writer: writer,
                    content: content
                }
                props.onRegist(notice);
            }

            return (
                <div className="aside">
                    <form>
                        <input type="text" placeholder="제목 입력" onChange={e => setTitle(e.target.value)} />
                        <input type="text" placeholder="작성자 입력" onChange={e => setWriter(e.target.value)} />
                        <textarea name="" id="" onChange={e => setContent(e.target.value)}></textarea>
                        <button type="button" onClick={handleClick}>{props.bt}</button>
                    </form>
                </div>
            );
        }

        // 게시물 목록 영역 
        function NoticeList(props) {
            return (
                <div className="content">
                    <table>
                        <thead>
                            <tr>
                                <th>No.</th>
                                <th>Title</th>
                                <th>Writer</th>
                                <th>Regdate</th>
                                <th>Hit</th>
                            </tr>
                        </thead>
                        <tbody>
                            {/* 
                                map() 은 js 의 배열메서드.  선언적 프로그래밍중 함수형 프로그램의 원칙 사용 
                                눈에 보이지 않으나 반복문을 스스로 수행한다. 개발자는 몇번째 반복인지 개입불가. 
                                개발자는 그냥 어떤 업무를 원하는지 선언만 하는 프로그래밍 방식. 
                            */}
                            
                            {props.noticeList.map((notice)=>(
                                <tr key={notice.noticeId} onClick={() => props.onSelectOne(notice)}>
                                    <td> </td>
                                     <td>{notice.title}</td>
                                    <td>{notice.writer}</td>
                                    <td>{notice.regdate}</td>
                                    <td>{notice.hit}</td>
                                </tr>
                            )
                            )}
                        </tbody>
                    </table>
                </div>
            );
        }

        // 게시물 자세기 보기 영역 
        // 자식 컴포넌트가 부모의 변수나 메서드를 접근하려면 props 를 이용할 수 있다 
        // notice: 게시물 한건 .. 컴포넌트가 바인딩 되어 바라보게 되면 개발자가 notice 정보를 변경만 해도 
        // 자동으로 UI 에 영향을 미친다. React, Vue 를 사용하는 이유 즉, UI 를 수정하는데 노력할 필요 없도록 한다. 
        function DetailForm(props) {
            function handleEdit(){
                
                // 유효성 체크 후 수정요청
                // !! 불리언 타입으로 강제변환만 수행. 
                /*  불리언 변환 + 값 반전
                    !0 true
                    !1 false
                    !"" true
                    !"s" false 

                    !! 불리언 타입으로 강제변환
                    !!0 false
                    !!1 true
                    !!"" false
                    !!"s" true
                    !!undefined false
                    !!{} true -> 비어있으나 객체가 존재하기 때문에 논리값으로 변환시 true 에 해당된다. 
                */
                const selectedId = !! props.notice.noticeId;
                // noticeId 에 값이 없을경우 false 반환. 

                if(!selectedId){
                    alert("수정원하는 게시물을 선택 해 주세요.");
                }

                const payload={
                    title:"수정",
                    writer:"수정자",
                    content:"내용용"
                }
                // props 로 전달된 onUpdate 변수명이 update 함수를 참조중 
                props.onUpdate(props.notice.noticeId,payload);
            }
            function handleDelete(){

            }
            
            return (
                <div className="detail">
                    <form>
                        <input type="text" value={props.notice.title} />
                        <input type="text" value={props.notice.writer} />
                        <textarea name="" id="" value={props.notice.content}></textarea>
                        <div className="btWr">
                            <button type="button" onClick={handleEdit}>수정</button>
                            <button type="button" onClick={handleDelete} style={{ backgroundColor: "red", color: "#fff" }}>삭제</button>
                        </div>
                    </form>
                </div>
            );
        }

        // React 의 render 의 경우 단일 출력의 형식을 따르기 때문에 최상위 wrap 컴포넌트를 생성하여 render 에 넘겨줘야 한다. 
        // 추후 개발 시 공통의 메서드나 컴포넌트가 변수의 공유 등에 아주 필수적이다!
        function App() {

            // 서버로부터 가져온 목록데이터를 화면에 표시할 UI 와 엮게될 바인딩 변수선언
            const [noticeList, setNoticeList] = React.useState([]);

            // 구조 분해 할당 notice를 선언하고 setNotice로 하여금 그걸 넣게 한다. 
            const [notice, setNotice] = React.useState({
                noticeId: "",
                title: "",
                writer: "",
                content: "",
                regdate: "",
                hit: 0
            });

            /* ---------------------------
              notice List 가져오기 
              컴포넌트 렌더링 직후 실행할 업무 *부수효과 side Effect* 를 실행 할 때 자주 사용되는 메서드. 
              ex_ 렌더링 직후 서버 호출 or DOM 접근 
              화면에 렌더링 직후 1회만 실행함 (효율적이다!)
            --------------------------- */
            React.useEffect(()=>{
                fetch("http://localhost:9999/api/notices",{method:"GET"})
                .then(res=>res.json()) // 첫번째 then 은 서버에서 응답이 왔을 때 실행됨. 성공 여부는 모름 
                                       // 성공 시? 서버로부터 전달된 데이터는 json 문자열 형태가 아니므로, json 문자열로 변환처리 필요 
                .then(data => {        // 여기서의 data 는 첫번째 then 에서 반환된 Promise 가 resolve 하며 넘겨준 값.
                    console.log("서버로부터 받은 데이터는? ", data);
                    setNoticeList(data)
                })
                .catch(err => console.log(err));
            },[]);

            /* ---------------------------
              서버에 비동기로 글 등록 요청
            --------------------------- */
            function regist(notice) {
                // JQuery Ajax 에 의존하지 않고, 브라우저 자체적으로 비동기 통신을 지원하는 기능이 fetch()
                console.log("나는 부모 컴포넌트의 App regist() 메서드이다~@!");
                fetch("http://localhost:9999/api/notices", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(notice) // 백엔드 스프링서버에서 Jackson 과 같은역할 
                }) // 프로미스가 한번 발생 
                    .then(res => res.json()) // < 여기서도 프로미스 발생 
                    .then(savedNotice => {
                        console.log("savedNotice is {}", savedNotice);
                    })
                    .catch(err => console.log(err));
            }

            /* ---------------------------
              게시글 상세보기 요청 
            --------------------------- */
            function selectOne(notice){
                console.log("부모의 selectOne 호출 성공.");
                console.log("자식 컴포넌트로부터 전달된  노티스는?", notice);
                setNotice(notice);
            }

            function update(noticeId,payload){
                console.log("부모컴포넌트 App 의 update 호출 ");
                // 웹브라우저에서 지원하는 비동기 통신 함수 
                // JQuery 에 의존x 
                fetch("http://localhost:9999/api/notices/"+noticeId,{
                    method:"PUT",
                    headers:{"Content-Type":"application/json"},
                    body: JSON.stringify(payload)
                })// 서버로부터 응답이 오면 아래 then() 이 수행. 
                .then(res => {
                    if(!res.ok) throw new Error("수정실패");
                    return res.json(); // 서버가 json 문자열을 전송 했다는 전제로 메서드 호출. 
                })
                .then(updated => {
                    console.log("수정결과로 응답받은 데이터: ",updated);
                })
                .catch(err=>{
                    console.log(err);
                });
            }

            return (
                <div id="wrapper" class="wrap">
                    <RegistForm bt="게시하기" onRegist={regist} />
                    <NoticeList noticeList={noticeList} onSelectOne={selectOne} />
                    <DetailForm notice={notice} onUpdate={update} />
                </div>
            );
        }

        root.render(<App />);
    </script>



</body>

</html>